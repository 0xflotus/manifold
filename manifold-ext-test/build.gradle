
description = 'Manifold :: ExtensionTest'

configurations {
  jpsCompiler
}

final List<String> errantTestPatterns =
        ['extensions/abc/benis_png/MyBenis_pngExt_Test.java',
         'extensions/java/util/List/ListExt_Test.java',
         'extensions/java/util/List/ListExt2_Test.java',
         'extensions/java/util/List/ListExt3_Test.java',
         'extensions/java/util/List/ListExt4_Test.java'
        ]

final FileTree errantTests = fileTree(sourceSets.test.output.resourcesDir).matching {
  exclude errantTestPatterns
}

dependencies {
  compile project(':manifold-ext')

  testCompile group: 'junit', name: 'junit', version:'4.12'
  testCompile project(':manifold-ext-test-api')
  testCompile files(sourceSets.test.output.resourcesDir).minus(errantTests)

  jpsCompiler project(':manifold').files('out/production/resources')
  jpsCompiler project(':manifold-ext').files('out/production/resources')
  jpsCompiler files('out/test/resources')//.minus(errantTests) //TODO this doesn't exclude files
}

compileTestJava.dependsOn(processTestResources)

idea.module {
  scopes.TEST.plus += [configurations.jpsCompiler]
//  excludeDirs += file('some-extra-exclude-dir')

  File logfile = new File('/tmp/ideamodule.log')
  StringBuffer lines = new StringBuffer()
  lines.append(new Date().toString()).append('\n')
  lines.append('start iml').append('\n')

  iml {
    final File imlFolder = rootProject.file('.idea/modules/' + project.name)
    generateTo = imlFolder
    lines.append(generateTo.absolutePath).append('\n')

    final File imlFile = new File(imlFolder, "${project.name}.iml")

    lines.append('imlFile is' + imlFile.absolutePath).append('\n')

    Node root = new XmlParser().parse(imlFile)

    final Node component = root.component.find { it.'@name' == 'NewModuleRootManager' }
    List<Node> content = component.content
    Node excludePatternNode = content.first().find { it.name() == 'excludePattern' }
    String excludePattern = String.join(';', errantTestPatterns)
    lines.append('exclude pattern is: ' + excludePattern).append('\n')

    if(!excludePatternNode) {
      content.first().appendNode('excludePattern', [pattern: excludePattern])
    } else {
//        excludePatternNode. replaceNode { node -> excludePattern(pattern: 'pleasegodwhy') }
      excludePatternNode.attributes().remove('pattern')
      excludePatternNode.attributes().putAll([pattern: excludePattern])
    }

    Writer writer = new StringWriter()
    new XmlNodePrinter(new PrintWriter(writer)).print(root)
    imlFile.write(writer.toString())

    lines.append('Done rewriting imlFile').append('\n')

//    withXml {
//      def node = it.asNode()
//      node.appendNode('iLoveGradle', 'true')
//    }

//    withXml { //XmlProvider xml ->
//      lines.append('In withXml').append('\n')
//      final Node component = it.asNode().component.find { it.'@name' == 'NewModuleRootManager' }
//      List<Node> content = component.content
//      Node excludePatternNode = content.first().find { it.name() == 'excludePattern' }
//      if(!excludePatternNode) {
//        content.first().appendNode('excludePattern', [pattern: String.join(';', errantTests)])
//      } else {
////        excludePatternNode. replaceNode { node -> excludePattern(pattern: 'pleasegodwhy') }
//        excludePatternNode.attributes().remove('pattern')
//        excludePatternNode.attributes().put('pattern', String.join(';', errantTests))
//      }
//      return it
//    }
  }
  lines.append('end iml').append('\n')

  logfile.write(lines.toString())
}

compileTestJava {
  doFirst {
    logger.quiet 'Muh test classpath:'
    classpath.files.each { File file -> logger.quiet(file.absolutePath) }
  }
//  options.fork = true
//  options.forkOptions.jvmArgs += ['-Xdebug', '-Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y']
}

test {
//  classpath = sourceSets.main.output.resourcesDir
//  doLast {
//    classpath.each { println it }
//  }
  // set JVM arguments for the test JVM(s)

//  jvmArgs '-Xplugin:Manifold'

  doFirst {
    logger.quiet 'Muh test execution classpath:'
    classpath.files.each { File file -> logger.quiet(file.absolutePath) }
  }

}

//  task printClasspath {
//    doLast {
//      configurations.testCompile.each { println it }
//      configurations.testRuntime.each { println it }
//    }
//  }