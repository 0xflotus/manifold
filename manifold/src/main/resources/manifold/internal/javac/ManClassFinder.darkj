package manifold.internal.javac;

import com.sun.tools.javac.code.ClassFinder;
import com.sun.tools.javac.code.Directive;
import com.sun.tools.javac.code.ModuleFinder;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.code.Symtab;
import com.sun.tools.javac.comp.Attr;
import com.sun.tools.javac.comp.Env;
import com.sun.tools.javac.main.JavaCompiler;
import com.sun.tools.javac.util.Context;
import com.sun.tools.javac.util.Name;
import com.sun.tools.javac.util.Names;
import java.util.HashSet;
import java.util.Set;
import javax.tools.JavaFileObject;
import manifold.util.JreUtil;
import manifold.util.ReflectUtil;


import static com.sun.tools.javac.code.Kinds.Kind.ERR;

public class ManClassFinder extends ClassFinder
{
  private final Context _ctx;
  private final ModuleFinder _moduleFinder;
  private final Symtab _symtab;

  public static ManClassFinder instance( Context ctx )
  {
    ClassFinder finder = ctx.get( classFinderKey );
    if( !(finder instanceof ManClassFinder) )
    {
      ctx.put( classFinderKey, (ClassFinder)null );
      finder = new ManClassFinder( ctx );
    }

    return (ManClassFinder)finder;
  }

  private ManClassFinder( Context context )
  {
    super( context );

    _ctx = context;
    _symtab = Symtab.instance( _ctx );
    _moduleFinder = ModuleFinder.instance( _ctx );

    JavaCompiler compiler = JavaCompiler.instance( context );
    ReflectUtil.field( compiler, "finder" ).set( this );
    sourceCompleter = (Symbol.Completer)ReflectUtil.field( compiler, "sourceCompleter" ).get();

    ReflectUtil.field( Symtab.instance( context ), "initialCompleter" ).set( getCompleter() );

    ReflectUtil.field( ManResolve.instance( context ), "finder" ).set( this );
  }

  @Override
  public Symbol.ClassSymbol loadClass( Symbol.ModuleSymbol msym, Name flatname ) throws Symbol.CompletionFailure
  {
    try
    {
      return super.loadClass( msym, flatname );
    }
    catch( Symbol.CompletionFailure ex )
    {
      Symbol.ClassSymbol extClassSym = loadWhileInExtensionClass( msym, flatname );
      if( extClassSym != null )
      {
        return extClassSym;
      }

      throw ex;
    }
  }

  private Symbol.ClassSymbol loadWhileInExtensionClass( Symbol.ModuleSymbol msym, Name flatname )
  {
    Env env = (Env)ReflectUtil.field( Attr.instance( _ctx ), "env" ).get();
    if( env == null )
    {
      return null;
    }

    JavaFileObject sourceFile = env.toplevel.getSourceFile();
    if( !(sourceFile instanceof GeneratedJavaStubFileObject) )
    {
      return null;
    }

    // Augmented classes must be able to access any module in the module graph. This is because
    // an augmented class consists of methods from the original class belonging to whatever
    // module AND methods defined in the extension class defined in the user's module (whatever
    // that may be) and the transitive closure of the user's module.
    //
    // Note this is exclusively a compile-time concern, considering the augments are never actually
    // added to the extended class -- Manifold rewrites the the bytecode at the call site to
    // call the extension class methods directly.

    Set<Symbol.ModuleSymbol> recoverableModules = new HashSet<>( _symtab.getAllModules() );

    recoverableModules.remove( msym );
    recoverableModules.add( _symtab.unnamedModule );
    addJavaSeModule( recoverableModules );

    for( Symbol.ModuleSymbol ms : recoverableModules )
    {
      if( ms.classLocation == null )
      {
        ms = _moduleFinder.findModule( ms );
      }

      if( ms.kind != ERR )
      {
        Symbol.ClassSymbol maybe = null;
        try
        {
          maybe = super.loadClass( ms, flatname );
        }
        catch( Symbol.CompletionFailure ignore )
        {
        }

        if( maybe != null && maybe.exists() )
        {
          return maybe;
        }
      }
    }

    return null;
  }

  private void addJavaSeModule( Set<Symbol.ModuleSymbol> recoverableModules )
  {
    if( JreUtil.isJava9Modular_compiler( _ctx ) )
    {
      Symbol.ModuleSymbol javaSeModule = ModuleFinder.instance( _ctx ).findModule( Names.instance( _ctx ).fromString( "java.se" ) );
      javaSeModule.complete();

      if( javaSeModule != null && javaSeModule.requires != null )
      {
        for( Directive.RequiresDirective directive : javaSeModule.requires )
        {
          recoverableModules.add( directive.getDependency() );
        }
      }
    }
  }
}
