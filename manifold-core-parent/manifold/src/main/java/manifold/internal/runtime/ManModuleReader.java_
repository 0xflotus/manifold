//!!
//!! WARNING: DO NOT REMOVE THIS FILE, ITS EXTENSION IS INTENTIONALLY .java_.  IT MUST BE COMPILED WITH JAVA 9.  THE
//!! RESULTING .class FILE MUST BE PLACED IN resources/manifold/internal/runtime
//!!

package manifold.internal.runtime;

import java.io.IOException;
import java.io.InputStream;
import java.lang.module.ModuleReader;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.Optional;
import java.util.stream.Stream;
import jdk.internal.loader.Resource;
import jdk.internal.loader.URLClassPath;
import manifold.util.StreamUtil;

/**
 * This class facilitates dynamic class loading via Type Manifolds in a Java 9 *modular* configuration.
 * Note non-modular projects use Java 8, Java 9 with -source = 8, or Java 9 with no module-info.java;
 * only a project using Java 9+ with module-info.java requires this class.
 * <p>
 * Basically ManModuleReader exploits Java 9's one-module-per-package rule...
 * Since Java 9 maps each package name uniquely to a single module, a class of a given package must
 * either load from that module or not load at all.  ManModuleReader contributes to this loading
 * by first delegating to the normal ModuleReader and, if the class fails to load, let Manifold
 * attempt to load it.
 */
public class ManModuleReader implements ModuleReader
{
  private final ModuleReader _delegate;
  private final URLClassPath _ucp;

  public ManModuleReader( ModuleReader delegate, URLClassPath ucp )
  {
    _delegate = delegate;
    _ucp = ucp;
  }

  @Override
  public Optional<URI> find( String name ) throws IOException
  {
    Optional<URI> uri = _delegate.find( name );
    if( !uri.isPresent() )
    {
      URL resource = _ucp.findResource( name, false );
      if( resource != null )
      {
        try
        {
          uri = Optional.of( resource.toURI() );
        }
        catch( URISyntaxException e )
        {
          throw new IOException( e );
        }
      }
    }
    return uri;
  }

  @Override
  public Optional<InputStream> open( String name ) throws IOException
  {
    Optional<InputStream> input = _delegate.open( name );
    if( !input.isPresent() )
    {
      Resource resource = _ucp.getResource( name, false );
      if( resource != null )
      {
        input = Optional.of( resource.getInputStream() );
      }
    }
    return input;
  }

  @Override
  public Optional<ByteBuffer> read( String name ) throws IOException
  {
    Optional<ByteBuffer> buffer = _delegate.read( name );
    if( !buffer.isPresent() )
    {
      Resource resource = _ucp.getResource( name, false );
      if( resource != null )
      {
        ByteBuffer bytes = ByteBuffer.wrap( StreamUtil.getContent( resource.getInputStream() ) );
        buffer = Optional.of( bytes );
      }
    }
    return buffer;
  }

  @Override
  public void release( ByteBuffer bb )
  {
    try
    {
      _delegate.release( bb );
    }
    catch( Exception ignore )
    {
    }
  }

  @Override
  public Stream<String> list() throws IOException
  {
    return _delegate.list();
  }

  @Override
  public void close() throws IOException
  {
    _delegate.close();
  }
}
