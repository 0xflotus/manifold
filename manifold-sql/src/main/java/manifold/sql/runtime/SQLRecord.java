package manifold.sql.runtime;

import manifold.sql.api.IModelConfig;
import manifold.sql.api.ISQLRecord;
import manifold.sql.api.ISQLResult;
import manifold.sql.util.DBSupport;

import java.sql.*;
import java.util.*;

public class SQLRecord implements ISQLResult, ISQLRecord
{
  private ValMap _values = new ValMap();
  private boolean _persisted;
  protected IModelConfig _config;


  public SQLRecord(String tableName, String idColumn ) {
    _config = null; /*new ModelConfig(tableName, idColumn, Collections.emptyList())*/;
  }

  public SQLRecord(IModelConfig config) {
    _config = config;
  }

  public SQLRecord() {/* dummy */}

  @Override
  public Object getRawValue( String property )
  {
    return _values.get( property );
  }

  @Override
  public void setRawValue( String property, Object value )
  {
    _values.put( property, value );
  }

  @Override
  public String getTableName()
  {
    return _config.getTableName();
  }

  public void configure(IModelConfig config) {
    // to be overridden by extension classes
  }

  public boolean isValid() {
    return _config == null || _config.isValid(this);
  }

  public void setConfig( IModelConfig config )
  {
    _config = config;
  }

  public boolean save() {
    if(!_config.isValidModifyingErrors(this)){
      System.out.println("Sorry, a validation error has occurred! Please check the errors.");
      return false;
    }
    if(_persisted) {
      return update();
    } else {
      return create();
    }
  }

  public boolean create()
  {
    StringBuilder valNames = new StringBuilder();
    StringBuilder valPlaceholders = new StringBuilder();
    LinkedList<Object> vals = new LinkedList<>();

    for( Iterator<Map.Entry<String, Object>> values = _values.entrySet().iterator(); values.hasNext(); )
    {
      Map.Entry<String, Object> pair = values.next();

      valNames.append( pair.getKey() );
      valPlaceholders.append( "?" );
      vals.add( pair.getValue() );

      if( values.hasNext() )
      {
        valNames.append( "," );
        valPlaceholders.append( "," );
      }
    }

    String sql = "INSERT INTO " + getTableName() + " (" + valNames + ")" + " VALUES (" + valPlaceholders + ")";

    try
    {
      PreparedStatement preparedStatement = DBSupport.prepareStatement( sql, vals, Statement.RETURN_GENERATED_KEYS );
      preparedStatement.executeUpdate();
      ResultSet tableKeys = preparedStatement.getGeneratedKeys();
      if(tableKeys.next()) {
        long autoGeneratedID = tableKeys.getInt( 1 );
        setRawValue( getIdColumn(), autoGeneratedID );
      }
    }
    catch( SQLException e )
    {
      e.printStackTrace();
    }
    return true;
  }

  private String getIdColumn()
  {
    return _config.getIdColumn();
  }

  public boolean update()
  {
    StringBuilder valNames = new StringBuilder();
    LinkedList<Object> vals = new LinkedList<>();

    for( Iterator<Map.Entry<String, Object>> values = _values.entrySet().iterator(); values.hasNext(); )
    {
      Map.Entry<String, Object> pair = values.next();
      if( !pair.getKey().equals( getIdColumn() ) )
      {
        valNames.append( pair.getKey() ).append("=?");
        vals.add(pair.getValue());
        if( values.hasNext() )
        {
          valNames.append( "," );
        }
      }
    }

    String sql = "UPDATE " + getTableName() + " SET " + valNames + " WHERE " + getIdColumn() + "=?" ;
    vals.add( getRawValue( getIdColumn() ) );

    try
    {
      PreparedStatement preparedStatement = DBSupport.prepareStatement( sql, vals );
      preparedStatement.executeUpdate();
    }
    catch( SQLException e )
    {
      e.printStackTrace();
    }
    _persisted = true;
    return true;
  }

  public static SQLRecord read( String tableName, String idColumn, Object idValue ) throws SQLException
  {
    PreparedStatement preparedStatement = DBSupport.prepareStatement( "SELECT * FROM " + tableName + " WHERE " + idColumn + "=?", Collections.singletonList( idValue ) );
    ResultSet resultSet = preparedStatement.executeQuery();
    if( resultSet.next() )
    {
      SQLRecord record = new SQLRecord( tableName, idColumn );
      ResultSetMetaData metaData = resultSet.getMetaData();
      int columnCount = metaData.getColumnCount();
      int i = 1;
      while( i <= columnCount )
      {
        int columnType = metaData.getColumnType( i );
        String columnName = metaData.getColumnName( i );
        switch( columnType )
        {
          case Types.INTEGER:
            record.setRawValue( columnName, resultSet.getInt( i ) );
            break;
          case Types.BIGINT:
            record.setRawValue( columnName, resultSet.getLong( i ) );
            break;
          default:
            record.setRawValue( columnName, resultSet.getObject( i ) );
            break;
        }
        i++;
      }
      return record;
    }
    else
    {
      return null;
    }
  }

  static <T> Iterator<T> select(String sql, List vals, Class impl) throws SQLException
  {
    PreparedStatement preparedStatement = DBSupport.prepareStatement( sql, vals );
    ResultSet resultSet = preparedStatement.executeQuery();
    return new SQLRecordResultSetIterator<T>(resultSet, impl);
  }

  static <T> Iterator<T> selectSingleColumn( String sql, List vals ) throws SQLException {
    PreparedStatement preparedStatement = DBSupport.prepareStatement(sql, vals);
    ResultSet resultSet = preparedStatement.executeQuery();
    return new SingleColumnResultSetIterator<T>(resultSet);
  }

  static Iterable<SQLRecord> executeStatement(String sql, List vals, Class impl) throws SQLException
  {
//    System.out.println(sql + " @SQLRecord 210"); debugging logging info
   PreparedStatement preparedStatement = DBSupport.prepareStatement(sql, vals);
    ResultSet resultSet = preparedStatement.executeQuery();
//    System.out.println(sql + " @SQLRecord 213");
    List<SQLRecord> results = new LinkedList<>();
    while (resultSet.next()){
      SQLRecord record = null;
      try {
        record = (SQLRecord) impl.newInstance();
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
      ResultSetMetaData metaData = resultSet.getMetaData();
      int columnCount = metaData.getColumnCount();
      int i = 1;
      while( i <= columnCount )
      {
        int columnType = metaData.getColumnType( i );
        String columnName = metaData.getColumnName( i );
        switch( columnType )
        {
          case Types.INTEGER:
            record.setRawValue( columnName, resultSet.getInt( i ) );
            break;
          case Types.BIGINT:
            record.setRawValue( columnName, resultSet.getLong( i ) );
            break;
          case Types.VARCHAR:
            record.setRawValue( columnName, resultSet.getString( i ));
          default:
            record.setRawValue( columnName, resultSet.getObject( i ) );
            break;
        }
        i++;
      }
      results.add(record);
    }
    return results;
  }

  


  public boolean delete()
  {
    LinkedList<Object> vals = new LinkedList<>();
    String sql = "DELETE FROM " + getTableName() + " WHERE " + getIdColumn() + "=?" ;
    vals.add( getRawValue( getIdColumn() ) );
    try
    {
      PreparedStatement preparedStatement = DBSupport.prepareStatement( sql, vals );
      preparedStatement.executeUpdate();
    }
    catch( SQLException e )
    {
      e.printStackTrace();
    }
    return true;
  }

  static class ValMap extends HashMap<String, Object>
  {
    @Override
    public Object put( String key, Object value )
    {
      return super.put( key.toLowerCase(), value );
    }

    @Override
    public Object get( Object key )
    {
      return super.get( ((String) key).toLowerCase() );
    }
  }

  private static abstract class ResultSetIterator<Q> implements Iterator<Q> {

    protected final ResultSetMetaData _metaData;
    protected final int _columnCount;
    private final ResultSet _resultSet;
    private boolean didNext = false;
    private boolean hasNext = false;

    public ResultSetIterator( ResultSet resultSet )
    {
      try
      {
        _resultSet = resultSet;
        _metaData = resultSet.getMetaData();
        _columnCount = _metaData.getColumnCount();
      }
      catch( SQLException e )
      {
        throw new RuntimeException( e );
      }
    }

    public Q next(){
      try
      {
        if( !didNext )
        {
          _resultSet.next();
        }
        Q val = transform( _resultSet );
        didNext = false;
        if( !hasNext() )
        {
          _resultSet.close();
        }
        return val;
      }
      catch( SQLException e )
      {
        throw new RuntimeException( e );
      }
    }

    protected abstract Q transform( ResultSet resultSet );

    public boolean hasNext(){
      if (!didNext) {
        try
        {
          hasNext = _resultSet.next();
        }
        catch( SQLException e )
        {
          throw new RuntimeException( e );
        }
        didNext = true;
      }
      return hasNext;
    }
  }

  private static class SQLRecordResultSetIterator<T> extends ResultSetIterator<T> {
    private final Class _sqlRecordType;

    public SQLRecordResultSetIterator( ResultSet resultSet, Class sqlRecordType )
    {
      super( resultSet );
      _sqlRecordType = sqlRecordType;
    }

    @Override
    protected T transform( ResultSet resultSet )
    {
      SQLRecord record = null;
      try {
        record = (SQLRecord) _sqlRecordType.newInstance();
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
      return (T) record.initFromResultSet( resultSet, _columnCount, _metaData );
    }
  }

  private static class SingleColumnResultSetIterator<T> extends ResultSetIterator<T> {

    public SingleColumnResultSetIterator( ResultSet resultSet )
    {
      super( resultSet );
    }

    @Override
    protected T transform( ResultSet resultSet )
    {
      try
      {
        return (T)getColumnValue( resultSet, _metaData.getColumnType( 1 ), 1 );
      }
      catch( SQLException e )
      {
        throw new RuntimeException( e );
      }
    }
  }

  private SQLRecord initFromResultSet( ResultSet resultSet, int columnCount, ResultSetMetaData metaData )
  {
    try
    {
      int i = 1;
      while( i <= columnCount )
      {
        int columnType = metaData.getColumnType( i );
        String columnName = metaData.getColumnName( i );
        Object value = getColumnValue(resultSet, columnType, i);
        setRawValue( columnName, value );
        i++;
      }
      return this;
    }
    catch( SQLException e )
    {
      throw new RuntimeException( e );
    }
  }

  private static Object getColumnValue( ResultSet resultSet, int columnType, int column ) throws SQLException
  {
    switch( columnType )
    {
      case Types.INTEGER:
        return resultSet.getInt( column );
      case Types.BIGINT:
        return resultSet.getLong( column );
      default:
        return resultSet.getObject( column );
    }
  }

}